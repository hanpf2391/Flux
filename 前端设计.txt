功能模块：动态区块式热力小地图 (最终版)
1. 功能目标
动态感知: 提供一个以用户为中心的“雷达式”小地图，实时按需加载并展示用户周围区域的热度。
分级展示: 用有限的几种颜色代表不同的热度等级，让用户能直观、快速地理解区域活跃度。
精确定位: 在小地图上清晰标示出用户当前主屏幕（视口）所观察的区域。
快速导航: 允许用户通过点击小地图快速传送到目标区域。
2. 核心定义
单元格 (Cell): 画布的最小单位，坐标为 (row_index, col_index)。
区块 (Chunk): 热度计算和数据加载的管理单元，由一个 9x9 的单元格矩阵构成。
区块ID (Chunk ID): 每个区块的唯一标识符，由其网格坐标 (grid_x, grid_y) 组成。
原始热力值 (Raw Heat Value): 一个区块内，包含了最新消息的单元格总数。其范围是 0 到 81。
热度等级 (Heat Tiers): 对原始热力值的分级归类。
冷区 (COLD): 热力值 0 - 20
暖区 (WARM): 热力值 21 - 50
热区 (HOT): 热力值 51 - 81
3. 后端详细设计
GET /api/heatmap/chunks
方法: GET
查询参数 (Query Parameter):
chunks (string, required): 一个由特定字符（如 ;）分隔的区块ID字符串。
示例: ?chunks=2,5;3,5;2,6
接收前端传来的 chunks 参数字符串。
解析参数: 将字符串解析成一个区块ID的坐标对列表，例如 [{x: 2, y: 5}, {x: 3, y: 5}, {x: 2, y: 6}]。
执行数据库查询: 调用“按需区块加载SQL”，将解析出的坐标对列表作为参数传入。
返回响应: 将SQL查询结果封装成JSON格式返回给前端。如果某个被请求的区块在数据库中没有任何数据，则它不会出现在返回的 data 数组中。
code
SQL
-- 参数: @CHUNK_SIZE = 9, @CHUNK_IDS = ((5,2), (5,3), (6,2), ...)
WITH
  LatestUniqueMessages AS (
    SELECT row_index, col_index
    FROM (
      SELECT row_index, col_index,
             ROW_NUMBER() OVER(PARTITION BY row_index, col_index ORDER BY updated_at DESC) as rn
      FROM messages
    ) AS RankedMessages
    WHERE rn = 1
  ),
  ChunkMapping AS (
    SELECT FLOOR(row_index / @CHUNK_SIZE) AS grid_y,
           FLOOR(col_index / @CHUNK_SIZE) AS grid_x
    FROM LatestUniqueMessages
  )
SELECT
  grid_y, grid_x, COUNT(*) AS heatValue
FROM
  ChunkMapping
WHERE (grid_y, grid_x) IN @CHUNK_IDS
GROUP BY grid_y, grid_x;
格式: JSON
示例:
code
JSON
{
  "chunkSize": 9,
  "data": [
    { "gridY": 5, "gridX": 2, "heatValue": 18 },
    { "gridY": 5, "gridX": 3, "heatValue": 45 },
    { "gridY": 6, "gridX": 2, "heatValue": 70 }
  ]
}
4. 前端详细设计
在前端代码中定义好配置，便于全局使用和修改。
code
JavaScript
// src/config.js
export const CHUNK_SIZE = 9;
export const HEAT_TIERS = {
  HOT:  { threshold: 51, color: '#FF4500', label: '热区 (51-81 条消息)' },
  WARM: { threshold: 21, color: '#FFD700', label: '暖区 (21-50 条消息)' },
  COLD: { threshold: 0,  color: '#1E90FF', label: '冷区 (0-20 条消息)' }
};
需要一个中央状态管理模块（或服务），包含：
viewport: { centerX, centerY, width, height } (响应式对象) - 存储主画布的视口信息。
heatmapData: Map<string, number> (响应式对象) - 全局唯一的区块热力数据缓存。Key为区块ID字符串 'gridX,gridY'，Value为原始热力值 (0-81)。
loadedChunks: Set<string> - 记录已向后端请求过的区块ID，防止重复请求。
创建一个HeatmapLoader服务或函数。
当主画布视口变化时，会计算出视野内需要的所有区块ID。
调用 HeatmapLoader.requestChunks(chunkIDs)。
HeatmapLoader 过滤掉已存在于 loadedChunks 的ID，然后打包剩余的ID，调用 GET /api/heatmap/chunks API。
API返回成功后，遍历 data 数组，将结果更新到全局的 heatmapData 中，并将请求过的ID存入 loadedChunks。
UI: 一个固定在屏幕角落的 <div>，内部包含一个 <canvas> 元素。
订阅: 组件需要实时响应 viewport 和 heatmapData 的变化。
渲染逻辑:
当 viewport 或 heatmapData 变化时，触发重绘函数。
重绘函数根据 viewport.centerX, viewport.centerY 计算出小地图需要展示的中心点和区块范围。
遍历小地图画布上的每一个像素（或逻辑单元），反算出它代表的是哪个区块ID。
在 heatmapData 中查找该区块ID的原始热力值。
如果找到了值，就调用一个 getTierColor(value) 的辅助函数，根据 HEAT_TIERS 配置，得到对应的颜色，并绘制该像素/单元。
如果没找到值（说明还未加载），则绘制透明或一个默认的背景色。
最后，在小地图的正中心绘制一个半透明矩形，代表 viewport 的范围。
点击导航: 监听小地图Canvas的 click 事件，将点击的像素坐标转换为世界坐标，并命令主画布移动到该位置。
一个独立的UI组件。
逻辑: 读取 HEAT_TIERS 配置，动态渲染出颜色方块和对应的文字说明（label）。这确保了图例与实际渲染逻辑的完全同步。
5. 初始加载流程 (User's First Impression)
用户进入页面，主画布中心定位到 (0,0) 或“黄金生成点”。
主画布根据初始视口，通过加载控制器请求第一批区块数据。
数据返回，heatmapData 被填充。
主画布（可选）和小地图同时监听到 heatmapData 的变化，并各自完成自己的首次渲染。
用户看到一个以自己为中心、部分点亮的小地图雷达，以及主画布上对应区域的内容。
这个设计方案详细、完整且可执行，将我们所有的讨论结果都融入其中，形成了一个健壮而高效的系统蓝图。